{"version":3,"sources":["..\\..\\..\\..\\UserInterface.fs"],"names":[],"mappings":"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","file":"UserInterface.js","sourcesContent":["ï»¿namespace AcademicMarkdown\r\nopen System\r\nopen Identifiers\r\nopen Types\r\nopen States\r\nopen Compiler\r\nopen Utility\r\nopen System.Text\r\nopen Fable.Core\r\nopen Fable.Import\r\nopen Fable.Import.Browser\r\nopen Fable.Core.JsInterop\r\n\r\nmodule UserInterface = \r\n\r\n    let compileAMD inputString = \r\n        let inputLines = inputString |> splitByLine\r\n\r\n        let mutable outputLines: string list = [];\r\n\r\n        initState()\r\n        let maxLineIndex = inputLines.Length - 1\r\n        let mutable lineIndex = 0\r\n        let mutable footnoteNumber = 1\r\n        //pre-process (all references)\r\n        lineIndex <- 0\r\n        while (lineIndex <= maxLineIndex) do\r\n            let eachLine = inputLines.[lineIndex]\r\n            match eachLine with\r\n            | IsLinkRef link -> \r\n                match link with\r\n                | Link (id,url,title) -> \r\n                    setLinks (Map.add id url links)\r\n                | _ -> ()\r\n            | IsFootnote footnote ->\r\n                match footnote with\r\n                | Footnote (id, text) ->\r\n                    setFootnotes (Map.add id (footnoteNumber.ToString() ,text) footnotes)\r\n                    footnoteNumber <- footnoteNumber + 1\r\n                | _ -> ()\r\n            | _ -> ()\r\n            lineIndex <- lineIndex + 1\r\n\r\n        //blockLevel\r\n        lineIndex <- 0\r\n        while (lineIndex <= maxLineIndex) do\r\n            let eachLine = inputLines.[lineIndex]\r\n            let output line = \r\n                outputLines <- line :: outputLines \r\n            match eachLine with\r\n            | IsLinkRef link -> ()\r\n            | IsFootnote footnote -> ()\r\n            | IsHorizontalRuleLine -> output \"<hr>\"\r\n            | IsHeading heading -> \r\n                heading |> makeHeading |> makeEmphasis |> output\r\n                addHeading heading\r\n            | IsAltHeading heading -> \r\n                heading |> makeHeading |> makeEmphasis |> output\r\n            | IsCodeBlockStart language ->\r\n                let mutable codes: string list = []\r\n                let mutable codeLineIndex = lineIndex + 1\r\n                let mutable foundCodeBlockEnd = false\r\n                while (codeLineIndex <= maxLineIndex && foundCodeBlockEnd = false) do\r\n                    let inputLine = inputLines.[codeLineIndex]\r\n                    match inputLine with\r\n                    | IsCodeBlockEnd ->\r\n                        foundCodeBlockEnd <- true\r\n                        lineIndex <- codeLineIndex\r\n                    | _ -> \r\n                        codes <- (htmlEncode inputLine) :: codes\r\n                        codeLineIndex <- codeLineIndex + 1\r\n                        \r\n                codes |> List.rev |> makeFencedCodeblock language |> output\r\n            | IsFlowChartStart ->\r\n                let flowChartId = uuid()\r\n                let mutable flowChartCode = \"\"\r\n                let mutable codeLineIndex = lineIndex + 1\r\n                let mutable foundCodeBlockEnd = false\r\n                while (codeLineIndex <= maxLineIndex && foundCodeBlockEnd = false) do\r\n                    let inputLine = inputLines.[codeLineIndex]\r\n                    match inputLine with\r\n                    | IsCodeBlockEnd ->\r\n                        lineIndex <- codeLineIndex\r\n                        foundCodeBlockEnd <- true\r\n                    | _ -> \r\n                        flowChartCode <- flowChartCode + inputLine + \"\\n\"\r\n                        codeLineIndex <- codeLineIndex + 1\r\n                        lineIndex <- codeLineIndex\r\n                setFlowCharts (Map.add flowChartId flowChartCode flowcharts)\r\n                output (\"<div id='\" + flowChartId + \"'>\" + flowChartCode + \"</div>\")\r\n            | IsCollapesStart (text:string)->\r\n                let id = uuid()\r\n                let button = if text.Length > 0 then text else \"Reveal\"\r\n                output (\"<button data-toggle='collapse' data-target='#\" + id + \"' class='btn btn-primary btn-xs'>\" + button + \"</button><br><div id='\" + id + \"' class='collapse'>\")\r\n            | IsCollapesEnd ->\r\n                output \"</div>\"\r\n            | IsExcelTableRow row ->\r\n                let mutable table = [row]\r\n                let mutable tableLineIndex = lineIndex + 1\r\n                let mutable foundTableEnd = false\r\n                while (tableLineIndex <= maxLineIndex && foundTableEnd = false) do\r\n                    let inputLine = inputLines.[tableLineIndex]\r\n                    match inputLine with\r\n                    | IsExcelTableRow cells ->\r\n                        table <- (cells :: table)\r\n                        lineIndex <- tableLineIndex\r\n                        tableLineIndex <- tableLineIndex + 1\r\n                    | _ -> \r\n                        foundTableEnd <- true\r\n                table <- table |> List.rev\r\n                output (makeTable table)\r\n             | IsPipeTableRow row ->\r\n                let mutable table = [row]\r\n                let mutable tableLineIndex = lineIndex + 2\r\n                let mutable foundTableEnd = false\r\n                while (tableLineIndex <= maxLineIndex && foundTableEnd = false) do\r\n                    let inputLine = inputLines.[tableLineIndex]\r\n                    match inputLine with\r\n                    | IsPipeTableRow cells ->\r\n                        table <- (cells :: table)\r\n                        lineIndex <- tableLineIndex\r\n                        tableLineIndex <- tableLineIndex + 1\r\n                    | _ -> \r\n                        foundTableEnd <- true\r\n                table <- table |> List.rev\r\n                output (makeTable table)\r\n            | IsEnumeratedList item ->\r\n                let mutable list = [item]\r\n                let mutable listLineIndex = lineIndex + 1\r\n                let mutable foundListEnd = false\r\n                while (listLineIndex <= maxLineIndex && foundListEnd = false) do\r\n                    let inputLine = inputLines.[listLineIndex]\r\n                    match inputLine with\r\n                    | IsEnumeratedList item ->\r\n                        list <- (item :: list)\r\n                        lineIndex <- listLineIndex\r\n                        listLineIndex <- listLineIndex + 1\r\n                    | _ -> \r\n                        foundListEnd <- true\r\n                list |> List.rev |> makeEnumeratedList |> output\r\n            | IsBlockquoteLine item ->\r\n                let mutable list = [item]\r\n                let mutable listLineIndex = lineIndex + 1\r\n                let mutable foundListEnd = false\r\n                while (listLineIndex <= maxLineIndex && foundListEnd = false) do\r\n                    let inputLine = inputLines.[listLineIndex]\r\n                    match inputLine with\r\n                    | IsBlockquoteLine item ->\r\n                        list <- (item :: list)\r\n                        lineIndex <- listLineIndex\r\n                        listLineIndex <- listLineIndex + 1\r\n                    | IsLazyQuoteBody item ->\r\n                        list <- (item :: list)\r\n                        lineIndex <- listLineIndex\r\n                        listLineIndex <- listLineIndex + 1\r\n                    | _ -> \r\n                        foundListEnd <- true\r\n                list |> List.rev |> makeBlockquote |> output\r\n             | IsIndentationCodeblock item ->\r\n                let mutable list = [item]\r\n                let mutable listLineIndex = lineIndex + 1\r\n                let mutable foundListEnd = false\r\n                let mutable blankLineCounter = 0\r\n                while (listLineIndex <= maxLineIndex && foundListEnd = false) do\r\n                    let inputLine = inputLines.[listLineIndex]\r\n                    match inputLine with\r\n                    | IsIndentationCodeblock item ->\r\n                        list <- (item :: list)\r\n                        lineIndex <- listLineIndex\r\n                        listLineIndex <- listLineIndex + 1\r\n                        blankLineCounter <- 0\r\n                    | IsBlankLine _ -> \r\n                        blankLineCounter <- blankLineCounter + 1\r\n                        list <- (\"\\n\" :: list)\r\n                        lineIndex <- listLineIndex\r\n                        listLineIndex <- listLineIndex + 1\r\n                    | _ -> \r\n                        foundListEnd <- true\r\n                        lineIndex <- listLineIndex - blankLineCounter - 1\r\n                list.[blankLineCounter..] |> List.rev |> makeIndentationCodeblock |> output\r\n            | IsCommentLine _ -> ()\r\n            | IsBlankLine _ ->\r\n                output \"<br>\"\r\n            | _ -> \r\n                eachLine + \"<br>\" |> makeEmphasis |> output\r\n            lineIndex <- lineIndex + 1\r\n        \r\n\r\n        //post-process \r\n        //table of contents\r\n        lineIndex <- 0\r\n        let outputLinesArray = outputLines |> List.toArray\r\n        while (lineIndex <= maxLineIndex) do\r\n            let eachLine = outputLinesArray.[lineIndex]\r\n            match eachLine with\r\n            | IsTableOfContent -> \r\n                outputLinesArray.[lineIndex] <- makeEmphasis (makeTableOfContent()  + \"<br>\")\r\n            | _ -> ()\r\n            lineIndex <- lineIndex + 1\r\n        outputLines <- outputLinesArray |> Array.toList         \r\n\r\n        outputLines <- makeFootnote() :: outputLines\r\n        outputLines|> List.rev |> String.concat \"\"\r\n        \r\n        \r\n//    compileAMD str\r\n    window?compileAMD <- compileAMD\r\n"]}